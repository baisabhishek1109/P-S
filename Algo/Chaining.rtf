{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fnil\fcharset0 MarkerFelt-Thin;}
{\colortbl;\red255\green255\blue255;\red34\green21\blue67;}
{\*\expandedcolortbl;;\cssrgb\c17716\c12301\c33221;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh15380\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs48 \cf2 \shad\shadx0\shady60\shadr6\shado56 \shadc0 Chaining Implementation ( Hash collision resolution):\
\
\
		Each cell will point to a linklist.\
\
	    pros:	\
			Dynamic sizing : If may grow more that the defined size.\
			Frequent collision are easily handled.\
	    cons:\
			In worst case search complexity could be O(n).\
\
	   SIZE = 50;\
	   arr = [];\
\
	  class Node\{\
			int data;\
			Node next;\
		\}\
\
	  Node start = new Node();\
	  start.data = -1;\
	  start.next = null;\
\
	  for i=0;i<50;i++\
			arr[i] = start;\
		\
	   get_index(item):\
			return  item % SIZE;\
\
	   add_into_chain(index,item):\
			temp = new Node();\
			temp.data = item;\
			temp.next = arr[index];\
			arr[index] = temp;\
		\
		\
	   arrange_values():\
		for i = 0;i<SIZE;i++:\
			print(\'91enter value\'92);\
			val = read();\
			index = get_index(val);\
			if arr[index].data != -1:\
				add_into_chain(index,item);\
			else:	\
				arr[index].data = item;	\
\
time complexity = \
		Best case :\
				Search = O(1)\
				Insert = O(1)\
		Worst case:	\
				Search = O(n)\
				Insert = O(1)\
\
\
				\
\
	  \
\
\
		}